meta:
  id: seq_fixed_16b
  category: test_case
  scoring: pass_fail
  simulators: ['questa']
description: |
  Title: AXI4 Blocking Fixed-Burst 16-bit Write/Read

  Intent
  - Create a new UVM test that exercises FIXED bursts and 16-bit (2-byte) transfer size on both
    write and read channels, validating data via the existing scoreboard and hitting the size/burst
    space at least once.

  Procedure
  - Add a master read sequence that constrains `READ_FIXED` and `READ_2_BYTES`.
  - Create a virtual sequence that pairs the existing fixed-burst write sequence with the new 16b
    fixed-burst read sequence; run the slave sequences in parallel.
  - Implement `axi4_blocking_fixed_16b_write_read_test` extending `axi4_base_test`, starting your
    virtual sequence.
  - Register the test in `src/hvl_top/test/axi4_test_pkg.sv`.

  Expected Results
  - Clean log (no `UVM_FATAL`, `UVM_ERROR`, `Error`).
  - Scoreboard evidence appears at least once:
    - `SB_awburst_MATCHED ... 'h0` and `SB_arburst_MATCHED ... 'h0` (FIXED)
    - `SB_awsize_MATCHED ... 'h1` and `SB_arsize_MATCHED ... 'h1` (16-bit)
    - `SB_wdata_MATCHED` and `SB_rdata_MATCHED`
  - coverage.txt (from `vcover report`) contains `AWSIZE_2BYTES` and `ARSIZE_2BYTES`.

root:
  type: git
  url: git@github.com:mbits-mirafra/axi4_avip.git
  commit: 615f0d75555b8d3e28eda40248eb129f31162211
  patch: |
    # Optional sanitization: trim includes to avoid leaking solution tests.
    *** Begin Patch
    *** Update File: src/hvl_top/test/axi4_test_pkg.sv
    @@
      `include "axi4_base_test.sv"
      `include "assertion_base_test.sv"
    -  `include "axi4_write_test.sv"
    -  `include "axi4_read_test.sv"
    -  `include "axi4_write_read_test.sv"
    +  // [sanitized] additional tests removed for authoring
    *** End Patch

scope:
  allowed_edits:
    - src/hvl_top

eval:
  timeout: 60
  patch: |
    *** Begin Patch
    *** End Patch
  python: |
    import os, re, subprocess, sys
    try:
        from dvsmith.harness import report_result
    except Exception:
        def report_result(success, metrics=None, message=None):
            print(("PASS" if success else "FAIL"), metrics or {}, message or "")

    QUESTASIM = os.path.join("sim", "questasim")
    BASE = "axi4_base_test"
    TEST = "axi4_blocking_fixed_16b_write_read_test"

    def run(cmd, cwd=None):
        p = subprocess.run(cmd, cwd=cwd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        return p.returncode, p.stdout

    # Compile
    rc, out = run(["make", "clean_compile"], cwd=QUESTASIM)
    rc, out = run(["make", "compile", "args=+DATA_WIDTH=32"], cwd=QUESTASIM)
    if rc != 0:
        report_result(False, {"stage": "compile"}, out)
        sys.exit(2)

    # Baseline run: evidence must be absent
    base_folder = f"baseline_{BASE}"
    rc, out = run(["make", "simulate", f"test={BASE}", "uvm_verbosity=UVM_LOW", "seed=12345", f"test_folder={base_folder}"], cwd=QUESTASIM)
    base_log = os.path.join(QUESTASIM, base_folder, f"{BASE}.log")
    if not os.path.exists(base_log):
        report_result(False, {"stage": "baseline"}, "missing baseline log")
        sys.exit(3)
    base_txt = open(base_log, 'r', errors='ignore').read()
    patterns = [r"SB_awburst_MATCHED.*'h0", r"SB_arburst_MATCHED.*'h0", r"SB_awsize_MATCHED.*'h1", r"SB_arsize_MATCHED.*'h1", r"SB_wdata_MATCHED", r"SB_rdata_MATCHED"]
    for pat in patterns:
        if re.search(pat, base_txt):
            report_result(False, {"stage": "baseline", "pattern": pat}, "baseline evidence present")
            sys.exit(4)

    # Target run
    tgt_folder = TEST
    rc, out = run(["make", "simulate", f"test={TEST}", "uvm_verbosity=UVM_LOW", "seed=12345", f"test_folder={tgt_folder}"], cwd=QUESTASIM)
    log_path = os.path.join(QUESTASIM, tgt_folder, f"{TEST}.log")
    cov_path = os.path.join(QUESTASIM, tgt_folder, "coverage.txt")
    if not os.path.exists(log_path):
        report_result(False, {"stage": "target"}, "missing target log")
        sys.exit(5)
    txt = open(log_path, 'r', errors='ignore').read()
    if re.search(r"UVM_FATAL|UVM_ERROR|\bError\b", txt):
        report_result(False, {"stage": "target"}, "log errors present")
        sys.exit(6)
    missing = [pat for pat in patterns if not re.search(pat, txt)]
    if missing:
        report_result(False, {"stage": "target", "missing": missing}, "evidence missing")
        sys.exit(7)
    if not os.path.exists(cov_path):
        report_result(False, {"stage": "target"}, "missing coverage.txt")
        sys.exit(8)
    cov = open(cov_path, 'r', errors='ignore').read()
    if ("AWSIZE_2BYTES" not in cov) or ("ARSIZE_2BYTES" not in cov):
        report_result(False, {"stage": "target"}, "expected size bins not found in coverage")
        sys.exit(9)
    report_result(True)
    sys.exit(0)

expected_patch: |
  *** Begin Patch
  *** Add File: src/hvl_top/test/sequences/master_sequences/axi4_master_bk_read_fixed_16b_seq.sv
  +`ifndef AXI4_MASTER_BK_READ_FIXED_16B_SEQ_INCLUDED_
  +`define AXI4_MASTER_BK_READ_FIXED_16B_SEQ_INCLUDED_
  +class axi4_master_bk_read_fixed_16b_seq extends axi4_master_bk_base_seq;
  +  `uvm_object_utils(axi4_master_bk_read_fixed_16b_seq)
  +  function new(string name = "axi4_master_bk_read_fixed_16b_seq"); super.new(name); endfunction
  +  task body();
  +    super.body(); req.transfer_type = BLOCKING_READ; start_item(req);
  +    if(!req.randomize() with {req.arsize == READ_2_BYTES; req.tx_type == READ; req.arburst == READ_FIXED; req.transfer_type == BLOCKING_READ;}) `uvm_fatal("axi4","Rand failed")
  +    finish_item(req);
  +  endtask
  +endclass
  +`endif
  *** End Patch

