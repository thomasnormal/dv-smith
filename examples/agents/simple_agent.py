#!/usr/bin/env python3
"""
Simple Sample Agent for DV-Smith

This agent demonstrates how to write a basic agent that can solve UVM test tasks.
It creates a minimal UVM test file based on the task requirements.

Usage:
    python examples/agents/simple_agent.py <task_file.md> <output_dir>
"""

import re
import sys
from pathlib import Path


class SimpleAgent:
    """A simple agent that generates basic UVM test code."""

    def __init__(self, task_file: Path) -> None:
        """Initialize agent with task specification.

        Args:
            task_file: Path to task markdown file
        """
        self.task_file = task_file
        self.task_spec = self._parse_task(task_file)

    def _parse_task(self, task_file: Path) -> dict:
        """Parse task specification from markdown.

        Args:
            task_file: Path to task markdown file

        Returns:
            Dictionary with task information
        """
        content = task_file.read_text()

        # Extract key information
        task_id_match = re.search(r"\*\*ID:\*\*\s*`([^`]+)`", content)
        bench_match = re.search(r"\*\*Bench:\*\*\s*(\S+)", content)
        goal_match = re.search(r"## Goal\n(.+?)(?=\n##|\Z)", content, re.DOTALL)
        hints_match = re.search(r"## Hints\n(.+?)(?=\n##|\Z)", content, re.DOTALL)

        # Extract acceptance criteria
        func_cov_match = re.search(r"Minimum:\s*(\d+\.?\d*)%", content)
        code_cov_match = re.search(r"Statements:\s*â‰¥(\d+\.?\d*)%", content)

        # Extract hints as list
        hints = []
        if hints_match:
            hint_text = hints_match.group(1)
            hints = [line.strip("- ").strip()
                    for line in hint_text.split("\n")
                    if line.strip().startswith("-")]

        return {
            "id": task_id_match.group(1) if task_id_match else "unknown",
            "bench": bench_match.group(1) if bench_match else "unknown",
            "goal": goal_match.group(1).strip() if goal_match else "",
            "hints": hints,
            "functional_coverage_min": float(func_cov_match.group(1)) if func_cov_match else 80.0,
            "code_coverage_min": float(code_cov_match.group(1)) if code_cov_match else 70.0
        }

    def generate_solution(self, output_dir: Path) -> Path:
        """Generate a solution for the task.

        Args:
            output_dir: Directory to write solution files

        Returns:
            Path to generated test file
        """
        output_dir.mkdir(parents=True, exist_ok=True)

        # Extract test name from task ID
        test_name = self.task_spec["id"].replace("task_", "").replace("_", " ").title().replace(" ", "")
        if not test_name.endswith("Test"):
            test_name += "Test"

        # Convert to snake_case for class name
        class_name = "".join(["_" + c.lower() if c.isupper() else c for c in test_name]).lstrip("_")

        # Generate SystemVerilog test code
        test_code = self._generate_test_code(class_name)

        # Write test file
        test_file = output_dir / f"{class_name}.sv"
        test_file.write_text(test_code)

        print(f"[SimpleAgent] Generated test: {test_file}")
        print(f"[SimpleAgent] Test class: {class_name}")
        print(f"[SimpleAgent] Goal: {self.task_spec['goal']}")

        return test_file

    def _generate_test_code(self, class_name: str) -> str:
        """Generate SystemVerilog UVM test code.

        Args:
            class_name: Name for the test class

        Returns:
            SystemVerilog test code
        """
        # Extract sequences from hints
        sequences = []
        for hint in self.task_spec["hints"]:
            # Look for mentions of sequences
            seq_match = re.search(r"(\w+_seq\w*)", hint.lower())
            if seq_match:
                sequences.append(seq_match.group(1))

        # If no sequences found, use a generic one
        if not sequences:
            sequences = ["base_sequence"]

        # Generate test code
        code = f"""`ifndef {class_name.upper()}_SV
`define {class_name.upper()}_SV

// Task: {self.task_spec['id']}
// Goal: {self.task_spec['goal']}
// Generated by SimpleAgent

class {class_name} extends base_test;

    `uvm_component_utils({class_name})

    function new(string name = "{class_name}", uvm_component parent = null);
        super.new(name, parent);
    endfunction

    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        `uvm_info(get_type_name(), "Build phase", UVM_LOW)
    endfunction

    virtual task run_phase(uvm_phase phase);
        {sequences[0]} seq;

        phase.raise_objection(this);
        `uvm_info(get_type_name(), "Starting test", UVM_MEDIUM)

        // Create and start sequence
        seq = {sequences[0]}::type_id::create("seq");

        // Configure sequence based on hints
"""

        # Add configuration based on hints
        for hint in self.task_spec["hints"]:
            if "transaction" in hint.lower() or "count" in hint.lower():
                # Try to extract number
                num_match = re.search(r"(\d+)", hint)
                if num_match:
                    code += f"        seq.num_transactions = {num_match.group(1)};\n"

        code += f"""
        // Start sequence on default sequencer
        seq.start(env.agent.sequencer);

        `uvm_info(get_type_name(), "Test completed", UVM_MEDIUM)
        phase.drop_objection(this);
    endtask

endclass

`endif // {class_name.upper()}_SV
"""

        return code

    def create_patch(self, output_dir: Path, solution_file: Path) -> Path:
        """Create a patch file for the solution.

        Args:
            output_dir: Output directory
            solution_file: Path to generated solution file

        Returns:
            Path to patch file
        """
        patch_file = output_dir / "solution.patch"

        # Create a simple patch that adds the new file
        # In a real scenario, this would be a proper git diff
        patch_content = f"""diff --git a/tests/{solution_file.name} b/tests/{solution_file.name}
new file mode 100644
index 0000000..0000000
--- /dev/null
+++ b/tests/{solution_file.name}
@@ -0,0 +1,{len(solution_file.read_text().split(chr(10)))} @@
"""

        # Add the content with + prefix
        for line in solution_file.read_text().split("\n"):
            patch_content += f"+{line}\n"

        patch_file.write_text(patch_content)
        print(f"[SimpleAgent] Created patch: {patch_file}")

        return patch_file


def main() -> None:
    """Main entry point for the simple agent."""
    if len(sys.argv) < 3:
        print("Usage: python simple_agent.py <task_file.md> <output_dir>")
        print("\nExample:")
        print("  python simple_agent.py gym/tasks/task_001.md solutions/")
        sys.exit(1)

    task_file = Path(sys.argv[1])
    output_dir = Path(sys.argv[2])

    if not task_file.exists():
        print(f"Error: Task file not found: {task_file}")
        sys.exit(1)

    print("=" * 60)
    print("Simple Agent for DV-Smith")
    print("=" * 60)
    print(f"Task file: {task_file}")
    print(f"Output directory: {output_dir}")
    print()

    # Create agent and generate solution
    agent = SimpleAgent(task_file)

    print("Task Information:")
    print(f"  ID: {agent.task_spec['id']}")
    print(f"  Bench: {agent.task_spec['bench']}")
    print(f"  Goal: {agent.task_spec['goal'][:80]}...")
    print(f"  Min Functional Coverage: {agent.task_spec['functional_coverage_min']}%")
    print(f"  Min Code Coverage: {agent.task_spec['code_coverage_min']}%")
    print(f"  Hints: {len(agent.task_spec['hints'])}")
    print()

    # Generate solution
    solution_file = agent.generate_solution(output_dir)
    patch_file = agent.create_patch(output_dir, solution_file)

    print()
    print("=" * 60)
    print("Solution Generated Successfully!")
    print("=" * 60)
    print(f"Test file: {solution_file}")
    print(f"Patch file: {patch_file}")
    print()
    print("Next steps:")
    print("  1. Review the generated test file")
    print("  2. Apply the patch: git apply solution.patch")
    print("  3. Evaluate the solution: dvsmith eval --task <task> --patch solution.patch")


if __name__ == "__main__":
    main()